import { definePlugin } from '@devtools/core/plugins';
import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';

const pluginName = '@devtools/builtin/package-readme';

type TemplateOptions = {
  /** Path to the template file */
  path: string;
  /** Markers for the beginning and end of a section @default ['#region', '#endregion'] */
  markers: [string, string];

  /** Delimiters for a single line comment. Must match the file's syntax */
  commentPattern: { start: string; end?: string };

  /** A message to be added as a comment to inform users that the section is generated */
  notice?: string;

  /** Content of the template file */
  content: string;
};

type TemplateUpdateOptions = {
  /** Name of the section to update */
  section: string;

  /** Content that should be inserted into the section */
  content: string;

  /** Where to insert the section, if the file does not contain it already */
  insert?: 'top' | 'bottom';

  /** A message to be added as a comment to inform users that the section is generated */
  notice?: string;
};

class Template {
  static get defaultOptions() {
    return {
      markers: ['#region', '#endregion'],
      notice: 'This section is generated. Do not edit manually!',
    };
  }

  constructor(protected options: TemplateOptions) {}

  static async load<T extends typeof Template>(
    this: T,
    path: string,
    options: Omit<TemplateOptions, keyof T['defaultOptions'] | 'content' | 'path'> & {
      [K in keyof T['defaultOptions']]?: K extends keyof TemplateOptions
        ? TemplateOptions[K]
        : never;
    },
  ) {
    const content = await readFile(path, 'utf8').catch((error) => {
      if (error.code === 'ENOENT') return '';

      throw error;
    });

    return new this({
      ...this.defaultOptions,
      ...options,
      path,
      content,
    } as unknown as TemplateOptions) as InstanceType<T>;
  }

  update({
    section: sectionName,
    content,
    insert,
    notice = this.options.notice,
  }: TemplateUpdateOptions) {
    const { commentPattern } = this.options;

    const markerComments = this.options.markers.map(
      (marker) => `${commentPattern.start} ${marker} ${sectionName} ${commentPattern.end}`,
    );
    const regExp = new RegExp(markerComments.join('[^]*'), 'm');
    const replacement = [
      `${markerComments[0]}\n${commentPattern.start} ${notice} ${commentPattern.end}`,
      content.trim(),
      markerComments[1],
    ].join('\n\n');

    if (!this.options.content.match(regExp)) {
      // console.warn(`Section "${sectionName}" not found in ${readmePath}. Adding it.`);
      if (insert === 'top') {
        this.options.content = [...markerComments, this.options.content].join('\n\n');
      } else if (insert === 'bottom') {
        this.options.content = [this.options.content, ...markerComments].join('\n\n');
      } else {
        throw new Error(
          `Section "${sectionName}" not found - add insert option for appending/prepending it automatically.`,
        );
      }
    }

    this.options.content = `${this.options.content.replace(regExp, replacement).trim()}\n`;
  }

  async save(to?: string) {
    await writeFile(to ?? this.options.path, this.options.content, 'utf8');
  }
}

class MarkdownTemplate extends Template {
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      commentPattern: { start: '<!--', end: '-->' },
    };
  }
}

const packageReadmePlugin = definePlugin<{
  // TODO: Define plugin options here
}>({
  name: pluginName,
  async setupPackage(pkg, { log }) {
    log.trace('Setting up package readme plugin', { pkg });

    const readmePath = join(pkg.dir, 'README.md');
    const readmeTemplate = await MarkdownTemplate.load(readmePath, {
      notice: `Generated by ${pluginName}. Do not edit manually, instead run \`devtools prepare\`.`,
    });

    readmeTemplate.update({
      section: 'header',
      insert: 'top',
      content: `# ${pkg.packageJson.name}

${pkg.packageJson.description ?? ''}
`,
    });

    await readmeTemplate.save();
    log.debug(`Updated README.md for package ${pkg.packageJson.name}`);
  },
});

export default packageReadmePlugin;

import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import { defineBuiltinPlugin } from '../lib/plugins';

// MARK: Template
// FIXME: Move to a separate package, like @toolsync/template

type TemplateOptions = {
  /** Path to the template file */
  path: string;
  /** Markers for the beginning and end of a section @default ['#region', '#endregion'] */
  markers: [string, string];

  /** Delimiters for a single line comment. Must match the file's syntax */
  commentPattern: { start: string; end?: string };

  /** A message to be added as a comment to inform users that the section is generated */
  notice?: string;

  /** Content of the template file */
  content: string;
};

type TemplateUpdateOptions = {
  /** Name of the section to update */
  section: string;

  /** Content that should be inserted into the section */
  content: string;

  /** Where to insert the section, if the file does not contain it already */
  insert?: 'top' | 'bottom';

  /** A message to be added as a comment to inform users that the section is generated */
  notice?: string;
};

class Template {
  static get defaultOptions() {
    return {
      markers: ['#region', '#endregion'],
      notice: 'This section is generated. Do not edit manually!',
    };
  }

  constructor(protected options: TemplateOptions) {}

  static async load<T extends typeof Template>(
    this: T,
    path: string,
    options: Omit<TemplateOptions, keyof T['defaultOptions'] | 'content' | 'path'> & {
      [K in keyof T['defaultOptions']]?: K extends keyof TemplateOptions
        ? TemplateOptions[K]
        : never;
    },
  ) {
    const content = await readFile(path, 'utf8').catch((error) => {
      if (error.code === 'ENOENT') return '';

      throw error;
    });

    return new this({
      ...this.defaultOptions,
      ...options,
      path,
      content,
    } as unknown as TemplateOptions) as InstanceType<T>;
  }

  update({
    section: sectionName,
    content,
    insert,
    notice = this.options.notice,
  }: TemplateUpdateOptions) {
    const { commentPattern } = this.options;

    const markerComments = this.options.markers.map(
      (marker) => `${commentPattern.start} ${marker} ${sectionName} ${commentPattern.end}`,
    );
    const regExp = new RegExp(markerComments.join('[^]*'), 'm');
    const replacement = [
      `${markerComments[0]}\n${commentPattern.start} ${notice} ${commentPattern.end}`,
      content.trim(),
      markerComments[1],
    ].join('\n\n');

    if (!this.options.content.match(regExp)) {
      // console.warn(`Section "${sectionName}" not found in ${readmePath}. Adding it.`);
      if (insert === 'top') {
        this.options.content = [...markerComments, this.options.content.trim()].join('\n\n');
      } else if (insert === 'bottom') {
        this.options.content = [this.options.content.trim(), ...markerComments].join('\n\n');
      } else {
        throw new Error(
          `Section "${sectionName}" not found - add it or use "insert" option for appending/prepending it automatically.`,
        );
      }
    }

    this.options.content = `${this.options.content.replace(regExp, replacement).trim()}\n`;
  }

  async save(to?: string) {
    await writeFile(to ?? this.options.path, this.options.content, 'utf8');
  }
}

export class MarkdownTemplate extends Template {
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      commentPattern: { start: '<!--', end: '-->' },
    };
  }
}

// MARK: Plugin

const pluginName = '@toolsync/builtin/package-readme';

const allBadges = ['npm-version'] as const;
type BadgesAvailable = (typeof allBadges)[number];

const packageReadmePlugin = defineBuiltinPlugin<{
  badges: boolean | BadgesAvailable[];
}>({
  name: pluginName,
  description: 'Generates README.md files for all packages in the workspace.',
  async setupPackage(pkg, { packages, log, options: { badges: _badges = allBadges } }) {
    log.trace('Setting up package readme plugin', { pkg });

    const badges = _badges === false ? [] : _badges === true ? allBadges : _badges;

    const readmePath = join(pkg.dir, 'README.md');
    const readmeTemplate = await MarkdownTemplate.load(readmePath, {
      notice: `Generated by ${pluginName}. Do not edit manually, instead run \`toolsync prepare\`.`,
    });

    const paragraphs = [
      `# ${pkg.packageJson.name}`,
      badges
        .map((badge) =>
          badge === 'npm-version'
            ? pkg.packageJson.private // FIXME: Also disable if published to a private registry
              ? ''
              : `![NPM Version](https://img.shields.io/npm/v/${pkg.packageJson.name})`
            : '',
        )
        .join(' '),
      pkg.packageJson.description,
    ];

    readmeTemplate.update({
      section: 'header',
      insert: 'top',
      content: paragraphs.flatMap((p) => (p?.trim() ? [p.trim()] : [])).join('\n\n'),
    });

    if (pkg.isRoot) {
      readmeTemplate.update({
        section: 'packages',
        insert: 'bottom',
        content: `## Packages

This repository contains the following packages:

${packages
  .filter((p) => !p.isRoot)
  .map(
    (p) =>
      `- [${p.packageJson.name}](${p.relativeDir}) - ${p.packageJson.description ?? '_no description_'}`,
  )
  .join('\n')}
`,
      });
    }

    await readmeTemplate.save();
    log.debug(`Updated README.md for package ${pkg.packageJson.name}`);
  },
});

export default packageReadmePlugin;

import { join } from 'path';
import { defineBuiltinPlugin } from '../lib/plugins';
import { MarkdownTemplate } from '@toolsync/template';
import { markdownTable } from 'markdown-table';
import type { Package } from '@toolsync/core/types';

const pluginName = '@toolsync/builtin/package-readme';

const allBadges = ['npm-version' as const, 'docs' as const];
type BadgesAvailable = (typeof allBadges)[number];

declare global {
  namespace Toolsync {
    interface ConfigMap {
      [pluginName]: {
        /**
         * The badges to add to each package
         * @default ['npm-version', 'docs']
         */
        badges?: boolean | BadgesAvailable[];
      };
    }
  }
}

function badgesForPackage(pkg: Package, badges: BadgesAvailable[]) {
  return badges
    .flatMap((badge) =>
      badge === 'npm-version'
        ? pkg.packageJson.private // FIXME: Also disable if published to a private registry
          ? []
          : [
              `[![NPM Version](https://img.shields.io/npm/v/${pkg.packageJson.name})](https://www.npmjs.com/package/${pkg.packageJson.name})`,
            ]
        : badge === 'docs' && pkg.packageJson.homepage
          ? [
              `[![Homepage](https://img.shields.io/badge/docs-default)](${pkg.packageJson.homepage})`,
            ]
          : [],
    )

    .filter(Boolean)
    .join(' ');
}

const packageReadmePlugin = defineBuiltinPlugin({
  name: pluginName,
  description: 'Generates README.md files for all packages in the workspace.',
  async setupPackage(pkg, { packages, log, options: { badges: _badges = allBadges } }) {
    log.trace('Setting up package readme plugin', { pkg });

    const badges = _badges === false ? [] : _badges === true ? allBadges : _badges;

    const readmePath = join(pkg.dir, 'README.md');
    const readmeTemplate = await MarkdownTemplate.load(readmePath, {
      notice: `Generated by ${pluginName}. Do not edit manually, instead run \`toolsync prepare\`.`,
    });

    const badgesForReadme = badgesForPackage(pkg, badges);
    const paragraphs = [
      `# ${pkg.packageJson.name}`,
      badgesForReadme ? `> ${badgesForReadme}` : undefined,
      pkg.packageJson.description,
    ];

    readmeTemplate.update({
      section: 'header',
      insert: 'top',
      content: paragraphs.flatMap((p) => (p?.trim() ? [p.trim()] : [])).join('\n\n'),
    });

    if (pkg.isRoot) {
      readmeTemplate.update({
        section: 'packages',
        insert: 'bottom',
        content: `## Packages

This repository contains the following packages:

${markdownTable([
  ['Name', 'Description', 'Links'],
  ...packages
    .filter((p) => !p.isRoot)
    // Private packages should come last in the list
    .sort((a, b) => {
      if (a.packageJson.private && !b.packageJson.private) return 1;
      if (!a.packageJson.private && b.packageJson.private) return -1;
      return a.packageJson.name.localeCompare(b.packageJson.name);
    })
    .map((p) => [
      `[${p.packageJson.name}](${p.relativeDir})`,
      `${p.packageJson.description ?? '_no description_'}`,
      badgesForPackage(
        p,
        badges.filter((b) => b !== 'docs'),
      ),
    ]),
])}
`,
      });
    }

    await readmeTemplate.save();
    log.debug(`Updated README.md for package ${pkg.packageJson.name}`);
  },
});

export default packageReadmePlugin;

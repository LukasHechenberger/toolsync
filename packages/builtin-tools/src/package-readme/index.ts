import { join } from 'path';
import { defineBuiltinPlugin } from '../lib/plugins';
import { MarkdownTemplate } from '@toolsync/template';
import { markdownTable } from 'markdown-table';
import type { Package } from '@toolsync/core/types';

const pluginName = '@toolsync/builtin/package-readme';

type BuiltinBadgeImplementation<S extends string> = {
  slug: S;
  render: (pkg: Package) => string | undefined;
};

const builtinBadges = [
  {
    slug: 'npm-version',
    render: (pkg) => {
      // FIXME: Also disable if published to a private registry
      if (!pkg.packageJson.private) {
        return `[![NPM Version](https://img.shields.io/npm/v/${pkg.packageJson.name})](https://www.npmjs.com/package/${pkg.packageJson.name})`;
      }
    },
  },
  {
    slug: 'docs',
    render: (pkg) => {
      if (pkg.packageJson.homepage) {
        return `[![Homepage](https://img.shields.io/badge/docs-default)](${pkg.packageJson.homepage})`;
      }
    },
  },
  {
    slug: 'vscode-extension',
    render: (pkg) => {
      if ('vscode' in (pkg.packageJson.engines ?? {}) && 'publisher' in pkg.packageJson) {
        const extensionId = `${pkg.packageJson.publisher}.${pkg.packageJson.name}`;

        return `[![Visual Studio Marketplace Version](https://img.shields.io/visual-studio-marketplace/v/${extensionId}?label=vscode)](https://marketplace.visualstudio.com/items?itemName=${extensionId})
`;
      }
    },
  } satisfies BuiltinBadgeImplementation<'vscode-extension'>,
] satisfies BuiltinBadgeImplementation<any>[];

const allBadges = ['npm-version' as const, 'docs' as const, 'vscode-extension' as const];
type BadgesAvailable = (typeof allBadges)[number];

declare global {
  namespace Toolsync {
    interface ConfigMap {
      [pluginName]: {
        /**
         * The badges to add to each package
         * @default ['npm-version', 'docs', 'vscode-extension']
         */
        badges?: boolean | BadgesAvailable[];
      };
    }
  }
}

function badgesForPackage(pkg: Package, badges: BadgesAvailable[]) {
  return badges
    .flatMap((badge) => {
      const implementation = builtinBadges.find((b) => b.slug === badge);
      if (!implementation) return [];

      const rendered = implementation.render(pkg);
      return rendered ? [rendered] : [];
    })
    .join(' ');
}

const packageReadmePlugin = defineBuiltinPlugin({
  name: pluginName,
  description: 'Generates README.md files for all packages in the workspace.',
  async setupPackage(pkg, { packages, log, options: { badges: _badges = allBadges } }) {
    log.trace('Setting up package readme plugin', { pkg });

    const badges = _badges === false ? [] : _badges === true ? allBadges : _badges;

    const readmePath = join(pkg.dir, 'README.md');
    const readmeTemplate = await MarkdownTemplate.load(readmePath, {
      notice: `Generated by ${pluginName}. Do not edit manually, instead run \`toolsync prepare\`.`,
    });

    const badgesForReadme = badgesForPackage(pkg, badges);
    const paragraphs = [`# ${pkg.packageJson.name}`, badgesForReadme, pkg.packageJson.description];

    readmeTemplate.update({
      section: 'header',
      insert: 'top',
      content: paragraphs.flatMap((p) => (p?.trim() ? [p.trim()] : [])).join('\n\n'),
    });

    if (pkg.isRoot) {
      readmeTemplate.update({
        section: 'packages',
        insert: 'bottom',
        content: `## Packages

This repository contains the following packages:

${markdownTable([
  ['Name', 'Description', 'Links'],
  ...packages
    .filter((p) => !p.isRoot)
    // Private packages should come last in the list
    .sort((a, b) => {
      if (a.packageJson.private && !b.packageJson.private) return 1;
      if (!a.packageJson.private && b.packageJson.private) return -1;
      return a.packageJson.name.localeCompare(b.packageJson.name);
    })
    .map((p) => [
      `[${p.packageJson.name}](${p.relativeDir})`,
      `${p.packageJson.description ?? '_no description_'}`,
      badgesForPackage(
        p,
        badges.filter((b) => b !== 'docs'),
      ),
    ]),
])}
`,
      });
    }

    await readmeTemplate.save();
    log.debug(`Updated README.md for package ${pkg.packageJson.name}`);
  },
});

export default packageReadmePlugin;

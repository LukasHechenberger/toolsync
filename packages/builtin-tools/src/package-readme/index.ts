import { join } from 'path';
import { defineBuiltinPlugin } from '../lib/plugins';
import { MarkdownTemplate } from '@toolsync/template';

const pluginName = '@toolsync/builtin/package-readme';

const allBadges = ['npm-version'] as const;
type BadgesAvailable = (typeof allBadges)[number];

declare global {
  namespace Toolsync {
    interface ConfigMap {
      [pluginName]: {
        /**
         * The badges to add to each package
         * @default ['npm-version']
         */
        badges?: boolean | BadgesAvailable[];
      };
    }
  }
}

const packageReadmePlugin = defineBuiltinPlugin({
  name: pluginName,
  description: 'Generates README.md files for all packages in the workspace.',
  async setupPackage(pkg, { packages, log, options: { badges: _badges = allBadges } }) {
    log.trace('Setting up package readme plugin', { pkg });

    const badges = _badges === false ? [] : _badges === true ? allBadges : _badges;

    const readmePath = join(pkg.dir, 'README.md');
    const readmeTemplate = await MarkdownTemplate.load(readmePath, {
      notice: `Generated by ${pluginName}. Do not edit manually, instead run \`toolsync prepare\`.`,
    });

    const paragraphs = [
      `# ${pkg.packageJson.name}`,
      badges
        .map((badge) =>
          badge === 'npm-version'
            ? pkg.packageJson.private // FIXME: Also disable if published to a private registry
              ? ''
              : `![NPM Version](https://img.shields.io/npm/v/${pkg.packageJson.name})`
            : '',
        )
        .join(' '),
      pkg.packageJson.description,
    ];

    readmeTemplate.update({
      section: 'header',
      insert: 'top',
      content: paragraphs.flatMap((p) => (p?.trim() ? [p.trim()] : [])).join('\n\n'),
    });

    if (pkg.isRoot) {
      readmeTemplate.update({
        section: 'packages',
        insert: 'bottom',
        content: `## Packages

This repository contains the following packages:

${packages
  .filter((p) => !p.isRoot)
  // Private packages should come last in the list
  .sort((a, b) => {
    if (a.packageJson.private && !b.packageJson.private) return 1;
    if (!a.packageJson.private && b.packageJson.private) return -1;
    return a.packageJson.name.localeCompare(b.packageJson.name);
  })
  .map(
    (p) =>
      `- [${p.packageJson.name}](${p.relativeDir}) - ${p.packageJson.description ?? '_no description_'}`,
  )
  .join('\n')}
`,
      });
    }

    await readmeTemplate.save();
    log.debug(`Updated README.md for package ${pkg.packageJson.name}`);
  },
});

export default packageReadmePlugin;
